# Introduction #

There are existing 5554 ECU's that can be re-purposed. These can function as low cost no soldering required boxes, that are currently being put in landfills. One such ECU is made by DMC. It comes with fuel injector control, spark control, and of course an 5554 that can run o5e code. A key obstacle is that it used a monitor chip, that does things like watch dog, and such tasks that make sure the overall package is functional. This appears to include an enable pin that disables the fuel injectors. This is likely used to turn off fuel in the even of a collision. If for any reason that monitor signal is not passed, it cuts the fuel. Which can be a problem, if a new program is entered into the 5554, as it has to communicate with the monitor chip to enable the fuel injectors.

# Details #
## General info ##
The monitor is a MC68H and is connected to the 5554 via SPI bus. This bus may or many not include other devices. The 5554 is the master. More found at this forum thread http://forum.open5xxxecu.org/viewtopic.php?f=3&t=137

## SPI coms ##
The SPI clock rate was sniffed / measured with a Saleae Logic Analyzer (LA) with a 24MHz sample rate it measured at 500kHz. Based on a Freescale SPI app note, the expected clock rates would have been 520.83kHz. http://www.ee.nmt.edu/~teare/ee308l/datasheets/S12SPIV3.pdf

However based on the below picture you can see it appears this is not a fixed clock rate, it's most likely generated via software.

![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/Keyon%20short%20run%2011-7-2012_clock_freq.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/Keyon%20short%20run%2011-7-2012_clock_freq.png)

The log file that generated the above picture can be found at this link http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/Keyon%20short%20run%2011-7-2012_clock_freq.logicdata

Note the overall frequency was always 500kHz, however the width or gap of the clock cycle could vary slightly. Most of the clock cycles were 1uS width and gap. However some times the width would be 1.0417uS with a gap of .9583uS, such that the overall period was always 500kHz. The variation in width was always 1.0417uS, this likely indicates it's being generated by a software tick instead of PLL, as PLL would not always have the exact same variation.

The log file that generated the below pictures can be found at this link, and can be opened with Saleae Logic 1.1.15 http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-keyout&out-keyon&start-run-then-MILlight-run-off-then_run_to_endoff_post-processed.logicdata

The above .logicdata log file was taken with a newer than 2000 Jeep. The LA was connected to the pins noted in the left hand view. Note p8 was pin 8. Such that MOSI was MOSI of the monitor chip. The general / major steps performed to get this log, started with the key off and door closed, the log was started, then door opened and key was turned on for about 5 seconds. Then the engine was started for about 5 seconds, then key turned off. The log continues until data stopped about 87 seconds after it started.

The 5554 sends packets by first pulling the enable line low for about 64uS before the first bit of the packet, then it sends the packet bytes, then it holds enable low about 64uS after the last bit. See below, note T1-T2 on the right bottom-ish. Also note the pin names are noted in left part of the picture near the channel color designations.

![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_enable-before-packet.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_enable-before-packet.png)
![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_enable-after-packet.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_enable-after-packet.png)

The packets are 9 bytes long, with an 8 byte payload. The Monitor's Serial Out (SO) packet is shifted by one byte, and the 5554 sends a extra byte to pad the clocking, such that the monitor's 8 bytes are transferred to the 5554 SPI buffer. In the below you can see the clock bursts for each byte, with each byte spaced by .128mS. total packet length is about 1.28mS long. See below.

![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_packet7-9bytes.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_packet7-9bytes.png)

This is CPHA=1 and CPOL=0 with the most sig digit first. See below, note the last transition of the data bits, both happen at the same edge while the decoder looks at the other clock edge.

![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_packet7_CPHA-1_CPOL-0.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_packet7_CPHA-1_CPOL-0.png)
![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/SPI_decoder_settings.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/SPI_decoder_settings.png)

With basic communications configured, we can use the SPI decoder to decode a stream of data, which will show the packets of data being sent. The exported CSV was converted to xls and post processed to help view the packets per the above notes. That xls can be found here.
[http://wiki.open5xxxecu.googlecode.com/git/DMC\_SPI/10-28-12-keyout&out-keyon&start-run-then\_MILlight-run-off-then\_run\_to\_endoff.xls](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-keyout&out-keyon&start-run-then_MILlight-run-off-then_run_to_endoff.xls)

Here's a picture of this xls file
![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_first-several-packets_spreadsheet.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_first-several-packets_spreadsheet.png)

The first 3 packets (noted as grey rows in the xls) appear to be special, but consistently the same. The enable bit pulls high for 44.7uS three times between the first 4 packets. Here are the bytes of the first three packets. These three bytes will need to be played before the stream can be used to hold on the fuel enable pin.

> 0x80 0x28 0x29 0x30 0x31 0x32 0x33 0x35 0x00 then enable high for 44.7uS

> 0x40 0x14 0x15 0x16 0x17 0x18 0x19 0x21 0x00 then enable high for 44.7uS

> 0x41 0x0D 0xF3 0xB0 0xF2 0x0C 0x4F 0x25 0x00 then enable high for 44.7uS

Here's a view of the first 4 packets and their spacing.

![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_first-4-packets.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_first-4-packets.png)

Then it starts what appear to be a continuous stream of packets(noted in xls as black and white rows). However the first couple streaming packets are spaced closer together than the normal stream packet spacing. This is likely because the system is still coming on line. These tighter spaced packets seems to take the next 8 packets. Here is the bytes of the first streaming packet.

> 0x30 0x01 0x12 0x00 0x00 0x00 0xBD 0x01 0x00 then enable high for 8.6mS up to 22mS.

After the first 12 packets, the streaming packets seem to have a consistent gap of 38.7mS. Here's a view of the first 16 packets and their spacing.

![![](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_first-16-packets.png)](http://wiki.open5xxxecu.googlecode.com/git/DMC_SPI/10-28-12-log_first-16-packets.png)

Here's my break down of the packets going to the monitor. It appears the packets to the 5554 can be ignored (noted by orange in the xls). This break down is based on my experience and gut feel from looking at the packet hex values noted in the xls. My primary concern was the monitors SI packet stream. Here's my break down of each streaming packet starting with the first byte, and incrementally progressing too the last.

> first 0x30 = The first byte appears to be a type of packet indicator, streaming packets seem to be 30. Below break down is only applicable to 0x30 type packets.

> 2nd 0x01 = The next appears to be a packet sequence number that starts with 01, goes to FF, and rolls over to 00 and continues incrementing once per packet.

> 3rd 0x12 = not sure perhaps 12 will always be OK.

> 4th 0x00 = not sure, it's 00 for the first 10 streaming packets, then FF after that, probably some kind of status indicator.

> 5th 0x00 = appears to be a state indicator. It changes to 01 then the injector is enabled before the next packet. It progressed to 02, then 03.

> 6th 0x00 = always 00, probably future expansion space/unused.

> 7th 0xBD = checksum "The 8-bit checksum is the 2's complement of the sum off all bytes. The checksum value, when added to the sum of all bytes produces a result of zero." as noted from here http://www.planetimming.com/checksum8.html

> 8th 0x01 = appears to be end of packet indicator

> 9th 0x00 = appears to be a clock holder for SI, it's always 00 it appears this allows the monitor chip to clear it's buffer.